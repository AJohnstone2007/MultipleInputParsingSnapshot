/*
*
* An abstract class which defines support methods for GLL parsers
* generated by the ART tool.
*
* (c) Adrian Johnstone 2013
*/
package uk.ac.rhul.cs.csle.art.v3.alg.gll.support;

import java.io.FileNotFoundException;
import java.util.LinkedList;
import java.util.List;

import uk.ac.rhul.cs.csle.art.cfg.lex.ARTTWEPairSet;
import uk.ac.rhul.cs.csle.art.core.ARTUncheckedException;
import uk.ac.rhul.cs.csle.art.term.ITerms;
import uk.ac.rhul.cs.csle.art.util.histogram.ARTHistogram;
import uk.ac.rhul.cs.csle.art.util.text.ARTText;
import uk.ac.rhul.cs.csle.art.v3.alg.ARTParserBase;
import uk.ac.rhul.cs.csle.art.v3.lex.ARTLexerV3;
import uk.ac.rhul.cs.csle.art.v3.manager.grammar.ARTGrammar;

public abstract class ARTGLLParserBase extends ARTParserBase {
  protected static boolean ARTTRACETWE = false;
  public ARTGLLRDT artRDT = null;

  protected int artWhitespaceEOSPrefixLength; // The amount of whitespace at the end of the file for acceptance handling

  // Pairs
  public int artInputPairBuffer[]; // Holds all unique input pairs; index into this buffer of a pair (a,i) is its handle in descriptors
  public int artInputPairIndex[][]; // Index of input pairs: contents of location (a, i) is the address of (a,i) in inputPair Buffer, a.k.a the pair's
                                    // handle
  public int artInputFirstPairAtLeftExtent[]; // For a given leftExtent, this holds the handle of the first pair in the inputPairBuffer. This is used as a
  public int artInputSuccessorIndex[][]; // Index of successor handles: contents of location (a, i) is the addess of first successor of (a,i)
  public int artCurrentInputPairReference; // handle for current input pair; index of this pair into inputPairBuffer
  public int artCurrentInputPairIndex; // Index into pair buffer used by parsers
  protected int artTokenExtent; // to be set to one plus the highest paraterminal's token number

  public ARTGLLParserBase(ARTGrammar artGrammar, ARTLexerV3 artLexer) {
    super(artGrammar, artLexer);
  }

  /**
   * Getters, setters and iterators
   */
  abstract public int artSPPFNodeLabel(int element);

  abstract public int artSPPFNodeLeftExtent(int element);

  abstract public int artSPPFNodeRightExtent(int element);

  abstract public int artSPPFNodePackedNodeList(int element);

  // Symbol nodes may be visited or selected
  abstract public boolean artSPPFNodeVisited(int element);

  abstract public void artSPPFNodeResetVisited(int element);

  abstract public void artSPPFNodeSetVisited(int element);

  public void artSPPFResetVisitedFlags() {
    for (int element = artSPPFNodeFirst(); element != 0; element = artSPPFNodeNext())
      artSPPFNodeResetVisited(element);
  }

  abstract public boolean artSPPFNodeSelected(int element);

  abstract public void artSPPFNodeResetSelected(int element);

  abstract public void artSPPFNodeSetSelected(int element);

  abstract public int artSPPFPackedNodeParent(int element);

  abstract public int artSPPFPackedNodeLabel(int element);

  abstract public int artSPPFPackedNodePivot(int element);

  abstract public int artSPPFPackedNodeLeftChildLabel(int element);

  abstract public int artSPPFPackedNodeRightChildLabel(int element);

  abstract public int artSPPFPackedNodePackedNodeList(int element);

  // Packed nodes may be suppressed or selected
  abstract public boolean artSPPFPackedNodeSuppressed(int element);

  abstract public void artSPPFPackedNodeResetSuppressed(int element);

  abstract public void artSPPFPackedNodeSetSuppressed(int element);

  abstract public boolean artSPPFPackedNodeSelected(int element);

  abstract public void artSPPFPackedNodeResetSelected(int element);

  abstract public void artSPPFPackedNodeSetSelected(int element);

  /*
   * Iterate over all SPPF nodes independent of linking
   */
  abstract public int artSPPFNodeFirst();

  abstract public int artSPPFNodeNext();

  abstract public int artSPPFNodeArity(int element);

  abstract public int artGSSNodeLabel(int element);

  abstract public int artGSSNodeLevel(int element);

  abstract public int artGSSNodeEdgeList(int element);

  abstract public int artGSSEdgeSPPFNode(int element);

  abstract public int artGSSEdgeSource(int element);

  abstract public int artGSSEdgeDestination(int element);

  abstract public int artGSSEdgeEdgeList(int element);

  /*
   * Iterate over all GSS nodes independent of linking
   */
  abstract public int artGSSNodeFirst();

  abstract public int artGSSNodeNext();

  /* Iterate over all GSS edges independent of linking */
  abstract public int artGSSEdgeFirst();

  abstract public int artGSSEdgeNext();

  /**
   * Internal methods
   */
  protected abstract int artFindRightmostTerminalSPPFNode();

  protected void artReportParseError(int rightMostSPPFNode) {
    int label = artSPPFNodeLabel(rightMostSPPFNode);
    if (artLexer.artInputLength <= 1)
      System.out.println("Parser error: unexpected empty string");
    else
      System.out.println(ARTText.echo("Parser error: found unexpected token after " + artLabelInternalStrings[label], artSPPFNodeRightExtent(rightMostSPPFNode),
          artLexer.artInputString));
  }

  /**
   * Public lexical access
   */
  public int artLabelEOS() {
    return ARTL_EOS;
  }

  public int artLabelEpsilon() {
    return ARTL_EPSILON;
  }

  public int artLabelAnnotation() {
    return ARTL_ANNOTATION;
  }

  public int artLabelDummy() {
    return ARTL_DUMMY;
  }

  public String artLabelToString(int label) {
    return artLabelStrings[label];
  }

  /**
   * Input string manipulation
   *
   * @
   */
  protected String artLexeme(int leftExtent, int rightExtent) {
    return artlexeme(leftExtent, rightExtent, 0, 0);
  }

  protected String artlexeme(int leftExtent, int rightExtent, int leftDelimiterWidth, int rightDelimiterWidth) {
    // May 2016 modified to strip whitespace from front of lexeme
    artLexer.artInputIndex = leftExtent;
    artLexer.artLexicalisePreparseWhitespace();

    // System.out.println("artlexeme " + artcharacterStringInputIndex + ":" + rightExtent + " '"
    // + artcharacterStringInput.substring(artcharacterStringInputIndex, rightExtent) + "'");
    return artLexer.artInputString.substring(artLexer.artInputIndex + leftDelimiterWidth, rightExtent - rightDelimiterWidth);
  }

  protected String artLexemeAsID(int leftExtent, int rightExtent) {
    return artLexeme(leftExtent, rightExtent);
  }

  protected int artLexemeAsSML_Integer(int leftExtent, int rightExtent) throws NumberFormatException {
    String s = artLexeme(leftExtent, rightExtent).replace('~', '-');
    int start = 0;
    int sign = 1;
    if (s.charAt(start) == '-') {
      sign = -1;
      start++;
    }
    int radix = 10;
    if (s.charAt(start) == '0' && s.charAt(start + 1) == 'x') {
      radix = 16;
      start += 2;
    }

    return sign * Integer.parseInt(s.substring(start), radix);
  }

  protected int artLexemeAsSML_Word(int leftExtent, int rightExtent) throws NumberFormatException {
    String s = artLexeme(leftExtent, rightExtent);
    int start = 2;
    int radix = 10;
    if (s.charAt(start) == 'x') {
      radix = 16;
      start++;
    }

    return Integer.parseInt(s.substring(start), radix);
  }

  protected double artLexemeAsSML_Real(int leftExtent, int rightExtent) throws NumberFormatException {
    return Double.parseDouble(artLexeme(leftExtent, rightExtent).replace('~', '-'));
  }

  protected String artLexemeAsSML_String(int leftExtent, int rightExtent) {
    return artLexemeAsString(leftExtent, rightExtent, 1, 1);
  }

  protected Character artLexemeAsSML_Char(int leftExtent, int rightExtent) {
    return artLexemeAsString(leftExtent, rightExtent, 2, 1).charAt(0);
  }

  protected int artLexemeAsInteger(int leftExtent, int rightExtent) throws NumberFormatException {
    return Integer.parseInt(artLexeme(leftExtent, rightExtent));
  }

  protected double artLexemeAsReal(int leftExtent, int rightExtent) throws NumberFormatException {
    return Double.parseDouble(artLexeme(leftExtent, rightExtent));
  }

  protected String artLexemeAsRawString(int leftExtent, int rightExtent) {
    return artLexemeAsRawString(leftExtent, rightExtent, 1, 1);
  }

  protected String artLexemeAsRawString(int leftExtent, int rightExtent, int leftDelimiterWidth, int rightDelimiterWidth) {
    return artlexeme(leftExtent, rightExtent, leftDelimiterWidth, rightDelimiterWidth);
  }

  protected String artLexemeAsString(int leftExtent, int rightExtent) {
    return artLexemeAsString(leftExtent, rightExtent, 1, 1);
  }

  // This function is used to convert string like lexemes into ASCII strings with escape sequence replacement
  // We are passed the leftExtent and the rightExtent,
  protected String artLexemeAsString(int leftExtent, int rightExtent, int leftDelimiterWidth, int rightDelimiterWidth) {
    // System.err.printf("%nlexemeAsString received %d to %d |%s| with delimiter widths L=%d, R=%d%n", leftExtent, rightExtent,
    // artcharacterStringInput.substring(leftExtent, rightExtent), leftDelimiterWidth, rightDelimiterWidth);
    artLexer.artInputIndex = leftExtent;
    artLexer.artLexicalisePreparseWhitespace();

    int left = artLexer.artInputIndex + leftDelimiterWidth;
    int right;
    int count = 0;
    for (right = left; right < rightExtent - rightDelimiterWidth;) {
      count++;
      if (artLexer.artInputString.charAt(right) == '\\') {
        if (Character.isDigit(artLexer.artInputString.charAt(right + 1)))
          right += 4;
        else
          right += 2;
      } else
        right++;
    }

    // System.err.printf("%nlexemeAsString string length is %d%n", count);
    char ret[] = new char[count];
    for (int i = 0; i < count; i++)
      ret[i] = ' ';
    int retI = 0;

    for (right = left; right < rightExtent - rightDelimiterWidth;) {
      if (artLexer.artInputString.charAt(right) == '\\') {
        if (artLexer.artInputString.charAt(right + 1) == 'u') {
          int value = Integer.parseInt(artLexer.artInputString.substring(right + 2, right + 6), 16);
          ret[retI++] = (char) value;
          right += 6;
        } else {
          switch (artLexer.artInputString.charAt(right + 1)) {
          case 'b':
            ret[retI++] = '\b';
            break;
          case 'n':
            ret[retI++] = '\n';
            break;
          case 'r':
            ret[retI++] = '\r';
            break;
          case 't':
            ret[retI++] = '\t';
            break;
          case 'f':
            ret[retI++] = '\f';
            break;
          default:
            ret[retI++] = artLexer.artInputString.charAt(right + 1);
          }
          right += 2;
        }
      } else
        ret[retI++] = artLexer.artInputString.charAt(right++);
    }

    return new String(ret);

  }

  public String[] getArtLabelInternalStrings() {
    return artLabelInternalStrings;
  }

  public void setArtLabelInternalStrings(String[] artLabelInternalStrings) {
    this.artLabelInternalStrings = artLabelInternalStrings;
  }

  public long getArteSOSInterpretCompleteTime() {
    return arteSOSInterpretCompleteTime;
  }

  public void setArteSOSInterpretCompleteTime(long arteSOSInterpretCompleteTime) {
    this.arteSOSInterpretCompleteTime = arteSOSInterpretCompleteTime;
  }

  /*
   * Parser global variables
   */
  protected int artRootSPPFNode;
  protected int artDummySPPFNode;
  protected int artRootGSSNode;

  protected int artPoppingDescriptorsToBeProcessed;
  protected int artNonpoppingDescriptorsToBeProcessed;
  protected int artPoppingDescriptorsToBeProcessedTail;
  protected int artNonpoppingDescriptorsToBeProcessedTail;
  protected int artCurrentDescriptor;
  protected int artCurrentRestartLabel;
  protected int artCurrentSPPFNode;
  protected int artCurrentSPPFRightChildNode;
  protected int artCurrentGSSNode;
  protected int artTemporarySPPFNode;

  protected int[] artFolds;
  protected int[] artGathers;
  protected int[] artpL;
  protected int[] artaL;
  protected int[] artcolonL;
  // protected int[] artsemiColonL;
  protected boolean[] artfiRL;
  protected boolean[] artfiPCL;
  protected boolean[] arteoOPL;
  protected boolean[] arteoRL;
  protected boolean[] arteoR_pL;
  protected boolean[] artPopD;
  protected boolean[] artIsLexical;

  /**
   * Getters
   */
  public int artSPPFRoot() {
    return artRootSPPFNode;
  }

  public int artSPPFPackedNodeLeftChild(int element) {
    int leftChildLabel = artSPPFPackedNodeLeftChildLabel(element);
    if (leftChildLabel == ARTL_DUMMY)
      return 0;
    else
      return artLookupSPPF(leftChildLabel, artSPPFNodeLeftExtent(artSPPFPackedNodeParent(element)), artSPPFPackedNodePivot(element));
  }

  public int artSPPFPackedNodeRightChild(int element) {
    return artLookupSPPF(artSPPFPackedNodeRightChildLabel(element), artSPPFPackedNodePivot(element), artSPPFNodeRightExtent(artSPPFPackedNodeParent(element)));
  }

  public int artGSSRoot() {
    return artRootGSSNode;
  }

  /**
   * GLL support functions
   */
  abstract protected int artLookupSPPF(int label, int leftExtent, int rightExtent);

  abstract protected int artFindSPPFInitial(int label, int leftExtent, int rightExtent);

  abstract protected int artFindSPPFEpsilon(int currentTokenIndex);

  abstract protected int artFindSPPFTerminal(int label, int currentTokenIndex);

  abstract protected int artFindSPPFTerminal(int label, int currentTokenIndex, int tokenRightExtent); // For MGLL version

  abstract protected int artFindSPPF(int label, int leftChild, int rightChild);

  abstract protected int artFindSPPFClosure(int parentLabel, int childLabel, int currentTokenIndex);

  abstract protected int artFindSPPFBaseNode(int parentLabel, int childLabel, int currentTokenIndex);

  abstract protected int artFindGSS(int stackTopLabel, int stackTop, int currentToken, int currentsppfNode);

  abstract protected void artPop(int stackTop, int currentTokenIndex, int currentsppfNode);

  abstract protected void artFindDescriptor(int restartLabel, int gssNode, int currentTokenIndex, int sppfNode);

  abstract protected boolean artTestRepeat(int regexpLabel, int stackTop, int currentTokenIndex, int derivationNode);

  // MGLL variants
  abstract protected int artFindGSSMGLL(int stackTopLabel, int stackTop, int currentToken, int currentsppfNode);

  abstract protected void artPopMGLL(int stackTop, int currentTokenIndex, int currentsppfNode);

  // Clustered variants
  abstract protected int artFindGSSClusteredInitial(int stackTopLabel, int stackTop, int currentToken, int currentsppfNode);

  abstract protected int artFindGSSClustered(int stackTopLabel, int stackTop, int currentToken, int currentsppfNode);

  abstract protected void artPopClustered(int nonTerminal, int k, int currentTokenIndex, int currentsppfNode);

  // Note this is esentially just an un-rename - it is here as a place holder in case we need to handle descriptors differently
  protected void artFindDescriptorClustered(int restartLabel, int gssNode, int currentTokenIndex, int sppfNode) {
    artFindDescriptor(restartLabel, gssNode, currentTokenIndex, sppfNode);
  };

  abstract protected void artCheckAcceptance();

  abstract boolean artNoDescriptors();

  abstract void artUnloadDescriptor();

  abstract void artUnloadDescriptorMGLL();

  abstract void artLoadDescriptorInitialMGLL();

  /**
   * Disambiguation
   */

  public ARTLexerV3 tweSet;

  void artDisambiguateWithinSPPFCollectTWERec(int element, boolean postUseTerminals) {
    // artText.printf("artDisambiguateWithinSPPFCollectTWERec() at node %s%n", artRenderSPPFNodeTitle(element));

    if (artSPPFNodeVisited(element)) {
      // artText.println("Already visited - aborting");
      return;
    }

    artSPPFNodeSetVisited(element);

    if (/*
         * (artNonterminalsDeclaredAsTerminals != null && artNonterminalsDeclaredAsTerminals[artSPPFNodeLabel(element)]) ||
         */(postUseTerminals && artSPPFNodePackedNodeList(element) == 0)) { // declared terminal
      // or leaf
      // artText.println("located TWE set element " + artLabelStrings[artSPPFNodeLabel(element)] + ", " + artSPPFNodeLeftExtent(element) + ", "
      // + artSPPFNodeRightExtent(element));
      if (artSPPFNodeLeftExtent(element) < artSPPFNodeRightExtent(element)) // suppress epsilons
        tweSet.tweSetUpdateExactMakeLeftSet(artSPPFNodeLabel(element), artSPPFNodeLeftExtent(element), artSPPFNodeRightExtent(element));
    }

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      int leftChildLabel = artSPPFPackedNodeLeftChildLabel(tmp);

      if (leftChildLabel != ARTL_DUMMY)
        artDisambiguateWithinSPPFCollectTWERec(artLookupSPPF(leftChildLabel, artSPPFNodeLeftExtent(artSPPFPackedNodeParent(tmp)), artSPPFPackedNodePivot(tmp)),
            postUseTerminals);

      artDisambiguateWithinSPPFCollectTWERec(
          artLookupSPPF(artSPPFPackedNodeRightChildLabel(tmp), artSPPFPackedNodePivot(tmp), artSPPFNodeRightExtent(artSPPFPackedNodeParent(tmp))),
          postUseTerminals);
    }

  }

  boolean artDisambiguateWithinSPPFSuppressRec(int element, boolean postUseTerminals) {
    // artText.printf("artDisambiguateWithinSPPFSuppressRec() at node %s%n", artRenderSPPFNodeTitle(element));

    if (tweSet.isIn(artSPPFNodeLabel(element), artSPPFNodeLeftExtent(element), artSPPFNodeRightExtent(element))) {
      // artText.println("located TWE set element " + artLabelStrings[artSPPFNodeLabel(element)] + ", " + artSPPFNodeLeftExtent(element) + ", "
      // + artSPPFNodeRightExtent(element));
      if (tweSet.isSuppressed(artSPPFNodeLabel(element), artSPPFNodeLeftExtent(element), artSPPFNodeRightExtent(element))) {
        artText.println("Marked as suppressed in TWE set");
        return true;
      }
    }

    if (artSPPFNodePackedNodeList(element) == 0) return false; // For leaf cells that are not in the TWEset

    if (!artSPPFNodeVisited(element)) { // rcurse for unvisited nodes

      artSPPFNodeSetVisited(element);

      // Now check suppressed bits across all packed node children
      for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
        boolean anySuppressed = false;

        int leftChildLabel = artSPPFPackedNodeLeftChildLabel(tmp);

        if (leftChildLabel != ARTL_DUMMY) if (artDisambiguateWithinSPPFSuppressRec(
            artLookupSPPF(leftChildLabel, artSPPFNodeLeftExtent(artSPPFPackedNodeParent(tmp)), artSPPFPackedNodePivot(tmp)), postUseTerminals))
          anySuppressed = true;

        if (artDisambiguateWithinSPPFSuppressRec(
            artLookupSPPF(artSPPFPackedNodeRightChildLabel(tmp), artSPPFPackedNodePivot(tmp), artSPPFNodeRightExtent(artSPPFPackedNodeParent(tmp))),
            postUseTerminals))
          anySuppressed = true;

        if (anySuppressed) artSPPFPackedNodeSetSuppressed(tmp);
      }
    }

    // Even if visited, we must recompute allSupressed since it is not stored anywhere
    boolean allSuppressed = true;
    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp))
      if (!artSPPFPackedNodeSuppressed(tmp)) allSuppressed = false;
    return allSuppressed;
  }

  public ARTHistogram artPackedFamilyArityHistogram;
  int edgeCount, nonterminalNodeCount, intermediateNodeCount, packedNodeCount, terminalNodeCount, epsilonNodeCount;

  void coreStatisticsRec(int element, int parent) {
    // artText.printf("summaryStatisticsRec() at node %s%n", artRenderSPPFNodeTitle(element));

    edgeCount++;

    if (artSPPFNodeVisited(element)) {
      // artText.println("Already visited - aborting");
      return;
    }

    artSPPFNodeSetVisited(element);

    if (artKindOfs[artSPPFNodeLabel(element)] == ARTK_INTERMEDIATE)
      intermediateNodeCount++;
    else if (artKindOfs[artSPPFNodeLabel(element)] == ARTK_NONTERMINAL)
      nonterminalNodeCount++;
    else if (artKindOfs[artSPPFNodeLabel(element)] == ARTK_EPSILON)
      epsilonNodeCount++;
    else
      terminalNodeCount++;

    long unsuppressedCount = 0, suppressedCount = 0;

    if (artKindOfs[artSPPFNodeLabel(element)] == ARTK_INTERMEDIATE || artKindOfs[artSPPFNodeLabel(element)] == ARTK_NONTERMINAL) {
      for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp))
        if (!this.artSPPFPackedNodeSuppressed(tmp))
          unsuppressedCount++;
        else
          suppressedCount++;
      if (suppressedCount != 0) artPackedFamilyArityHistogram.update(unsuppressedCount);
      if (suppressedCount != 0 && unsuppressedCount == 0) System.out.println("Symbol/intermediate node " + artRenderSPPFNodeTitle(element)
          + " under packed node " + artRenderSPPFPackedNodeTitle(parent) + " has no unsuppressed pack nodes");
      if (unsuppressedCount > 1) {
        System.out.println("Symbol/intermediate node " + artRenderSPPFNodeTitle(element) + " under packed node " + artRenderSPPFPackedNodeTitle(parent)
            + " has multiple unsuppressed pack nodes");
        for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp))
          if (!this.artSPPFPackedNodeSuppressed(tmp)) System.out.println("  " + artRenderSPPFPackedNodeTitle(tmp));
      }
    }

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      if (artSPPFPackedNodeSuppressed(tmp)) continue;

      edgeCount++;

      packedNodeCount++;

      int leftChildLabel = artSPPFPackedNodeLeftChildLabel(tmp);

      if (leftChildLabel != ARTL_DUMMY)
        coreStatisticsRec(artLookupSPPF(leftChildLabel, artSPPFNodeLeftExtent(artSPPFPackedNodeParent(tmp)), artSPPFPackedNodePivot(tmp)), tmp);

      coreStatisticsRec(artLookupSPPF(artSPPFPackedNodeRightChildLabel(tmp), artSPPFPackedNodePivot(tmp), artSPPFNodeRightExtent(artSPPFPackedNodeParent(tmp))),
          tmp);
    }
  }

  public void coreStatistics() {
    artSPPFResetVisitedFlags();
    artPackedFamilyArityHistogram = new ARTHistogram();

    edgeCount = -1;
    nonterminalNodeCount = intermediateNodeCount = packedNodeCount = terminalNodeCount = epsilonNodeCount = 0;
    if (artSPPFRoot() != 0) coreStatisticsRec(artSPPFRoot(), 0);
    artSPPFResetVisitedFlags();
    System.out.println("Edge count: " + edgeCount + "\nNode counts: nonterminal " + nonterminalNodeCount + ", intermediate " + intermediateNodeCount
        + ", packed " + packedNodeCount + ", terminal " + terminalNodeCount + ", epsilon " + epsilonNodeCount + " total: "
        + (nonterminalNodeCount + intermediateNodeCount + packedNodeCount + terminalNodeCount + epsilonNodeCount));
    System.out.println("Packed node family arity histogram: " + artPackedFamilyArityHistogram.toString());

    if (artPackedFamilyArityHistogram.bucketValue(0) != 0) System.out.println("** Warning: choosers have suppressed an entire packed node family");
  }

  int countSentencesAmbiguityCount;

  class SentenceTrieNode {
    int token;
    SentenceTrieNode sibling, child;

    public SentenceTrieNode(int token, SentenceTrieNode sibling) {
      this.token = token;
      this.sibling = sibling;
    }

    SentenceTrieNode findChild(int token) {
      for (SentenceTrieNode tmp = child; tmp.sibling != null; tmp = tmp.sibling)
        if (tmp.token == token) return tmp;

      child = new SentenceTrieNode(token, child);

      return child;
    }
  }

  void countSentencesRec(int element, SentenceTrieNode trieNode) {
    // artText.printf("countSentencesRec() at node %s%n", artRenderSPPFNodeTitle(element));
    SentenceTrieNode newTrieNode = trieNode;
    if (artSPPFNodeVisited(element)) {
      // artText.println("Already visited - aborting");
      return;
    }

    artSPPFNodeSetVisited(element);

    int unsuppressedPackedNodes = 0;

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      if (artSPPFPackedNodeSuppressed(tmp)) continue;
      unsuppressedPackedNodes++;

      int leftChildLabel = artSPPFPackedNodeLeftChildLabel(tmp);

      if (leftChildLabel != ARTL_DUMMY)
        countSentencesRec(artLookupSPPF(leftChildLabel, artSPPFNodeLeftExtent(artSPPFPackedNodeParent(tmp)), artSPPFPackedNodePivot(tmp)), newTrieNode);

      countSentencesRec(artLookupSPPF(artSPPFPackedNodeRightChildLabel(tmp), artSPPFPackedNodePivot(tmp), artSPPFNodeRightExtent(artSPPFPackedNodeParent(tmp))),
          newTrieNode);
    }

    if (unsuppressedPackedNodes > 1) countSentencesAmbiguityCount++;
  }

  void countSentences() {
    countSentencesAmbiguityCount = 0;
    artSPPFResetVisitedFlags();
    if (artSPPFRoot() != 0) countSentencesRec(artSPPFRoot(), new SentenceTrieNode(0, null));
    artSPPFResetVisitedFlags();
    System.out.println("Whilst counting sentences, found " + countSentencesAmbiguityCount + " ambiguous nodes");
  }

  @Override
  public ARTLexerV3 artProcessPostParseTWE(boolean postUseTerminals) {
    // System.out.println("\n** Summary SPPF statistics before postparse disambiguation");
    // coreStatistics();

    // System.out.println("\n** Commencing SPPF traversal to collect TWESet");
    tweSet = new ARTLexerV3(artHigher, artLonger, artLexer.artInputString, artLexer.artInputLength, ARTL_EOS, /* artLabelInternalStrings */ artLabelStrings,
        artDirectives);

    // Normalise the TWE set by putting an empty set into each null position
    for (int i = 0; i < tweSet.tweSet.length; i++)
      if (tweSet.tweSet[i] == null) tweSet.tweSet[i] = new ARTTWEPairSet();
    tweSet.tweSetUpdateExactMakeLeftSet(0, tweSet.tweSet.length - 2, tweSet.tweSet.length - 1); // Jam in final EoS
    // System.out.println("SPPF-derived TWE set initial state");
    // tweSet.printTWESet(null, true);

    artSPPFResetVisitedFlags(); // probably redundant, but still
    if (artSPPFRoot() != 0) artDisambiguateWithinSPPFCollectTWERec(artSPPFRoot(), postUseTerminals);

    // // System.out.println("\n** Running suppressors and computinglexicalisations on SPPF derived TWE set");
    // tweSet.applyChoosers();
    //
    // System.out.println("SPPF-derived TWE set");
    // tweSet.printTWESet(null, true);

    // if (artDirectives.b("tweCounts")) tweSet.computeLexerData();
    // artSPPFResetVisitedFlags();
    //
    // artDisambiguateWithinSPPFSuppressRec(artSPPFRoot(), postUseTerminals);
    //
    // System.out.println("SPPF-derived TWE after postparse disambiguation");
    // tweSet.printTWESet(null, true);
    // System.out.println("\n** Summary SPPF statistics after postparse disambiguation");
    // coreStatistics();
    //
    // countSentences();

    return tweSet;
  }

  private void artDisambiguatePriorityLongestMatchRec(int element) {
    // artText.printf("artDisambiguatePriorityLongestMatchRec() at node %d%n", element);

    if (artSPPFNodeVisited(element)) {
      // artText.println("Already visited - returning");
      return;
    }

    artSPPFNodeSetVisited(element);

    int candidate = 0;
    int candidatePivot = -1;

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      // artText.printf("Test: iterated to pack node node %d%n", tmp);
      if (candidate == 0 || (artSPPFPackedNodeLabel(tmp) < artSPPFPackedNodeLabel(candidate))
          || ((artSPPFPackedNodeLabel(tmp) == artSPPFPackedNodeLabel(candidate)) && (artSPPFPackedNodePivot(tmp) > candidatePivot))) {
        // artText.printf("Updating candidate to pack node node %d%n", tmp);
        candidate = tmp;
        candidatePivot = artSPPFPackedNodePivot(tmp);
      }
    }

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      // artText.printf("Suppress: iterated pack node node %d%n", tmp);
      if (tmp != candidate) {
        // artText.printf("Suppressing pack node %d%n", tmp);
        artSPPFPackedNodeSetSuppressed(tmp);
      }
    }

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      int leftChildLabel = artSPPFPackedNodeLeftChildLabel(tmp);

      if (leftChildLabel != ARTL_DUMMY)
        artDisambiguatePriorityLongestMatchRec(artLookupSPPF(leftChildLabel, artSPPFNodeLeftExtent(artSPPFPackedNodeParent(tmp)), artSPPFPackedNodePivot(tmp)));

      artDisambiguatePriorityLongestMatchRec(
          artLookupSPPF(artSPPFPackedNodeRightChildLabel(tmp), artSPPFPackedNodePivot(tmp), artSPPFNodeRightExtent(artSPPFPackedNodeParent(tmp))));
    }
  }

  @Override
  public void artDisambiguatePriorityLongestMatch() {
    if (artSPPFRoot() != 0) artDisambiguatePriorityLongestMatchRec(artSPPFRoot());
    artSPPFResetVisitedFlags();
  }

  private void artChooseRec(int element) {
    // artText.printf(ARTTextLevel.TRACE, "ART ChooseRec() at node %d %s%n", element, artSPPFNodeLabel(element));

    if (artSPPFNodeVisited(element)) {
      // artText.println(ARTTextLevel.TRACE, "Already visited - aborting");
      return;
    }

    artSPPFNodeSetVisited(element);

    for (int outer = artSPPFNodePackedNodeList(element); outer != 0; outer = artSPPFPackedNodePackedNodeList(outer)) {
      for (int inner = artSPPFNodePackedNodeList(element); inner != 0; inner = artSPPFPackedNodePackedNodeList(inner)) {
        // artText.printf("Choose testing packed nodes %d %d%n", inner, outer);

        if (artHigher[artSPPFPackedNodeLabel(outer)] != null && artHigher[artSPPFPackedNodeLabel(outer)].get(artSPPFPackedNodeLabel(inner))) {
          // artText.printf("Higher suppresses pack node %d under symbol node %d%n", inner, element);
          artSPPFPackedNodeSetSuppressed(inner);
        }

        if (artLonger[artSPPFPackedNodeLabel(outer)] != null && artLonger[artSPPFPackedNodeLabel(outer)].get(artSPPFPackedNodeLabel(inner))
            && artSPPFPackedNodePivot(outer) > artSPPFPackedNodePivot(inner)) {
          // artText.printf("Longer suppresses pack node %d under symbol node %d%n", inner, element);
          artSPPFPackedNodeSetSuppressed(inner);
        }

        if (artShorter[artSPPFPackedNodeLabel(outer)] != null && artShorter[artSPPFPackedNodeLabel(outer)].get(artSPPFPackedNodeLabel(inner))
            && artSPPFPackedNodePivot(outer) < artSPPFPackedNodePivot(inner)) {
          // artText.printf("Shorter suppresses pack node %d under symbol node %d%n", inner, element);
          artSPPFPackedNodeSetSuppressed(inner);
        }
      }
    }

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      int leftChildLabel = artSPPFPackedNodeLeftChildLabel(tmp);

      if (leftChildLabel != ARTL_DUMMY)
        artChooseRec(artLookupSPPF(leftChildLabel, artSPPFNodeLeftExtent(artSPPFPackedNodeParent(tmp)), artSPPFPackedNodePivot(tmp)));

      artChooseRec(artLookupSPPF(artSPPFPackedNodeRightChildLabel(tmp), artSPPFPackedNodePivot(tmp), artSPPFNodeRightExtent(artSPPFPackedNodeParent(tmp))));
    }
  }

  @Override
  public void artChoose() {
    if (artSPPFRoot() != 0) artChooseRec(artSPPFRoot());
    artSPPFResetVisitedFlags();
  }

  /*
   * Derivation selection and construction
   */
  // returns node label if an ^^ has been encountered or we are intermediate, otherwise zero
  private int artDerivationAsTermRec(int element, List<Integer> parentChildren, ITerms iTerms, int fold) {
    // artText.printf("ArtDerivationAsTermRec() at node %d %s with fold arg %d%n", element, artLabelInternalStrings[artSPPFNodeLabel(element)], fold);
    if (artSPPFNodeVisited(element)) throw new ARTUncheckedException("ArtDerivationAsTermRec() found cycle in derivation");

    // 1. Decide whether to append our children onto our parent's children or whether we will eventually make a new DT node
    List<Integer> children;
    if (artKindOfs[artSPPFNodeLabel(element)] == ARTK_INTERMEDIATE || fold != ARTFOLD_NONE)
      children = parentChildren; // otherwise inset children into parent's children
    else {
      children = new LinkedList<>();
      // artText.printf(" made new linked list at node %d%n", element);
    }

    // 2. Gather return values from left and right children
    artSPPFNodeSetVisited(element);

    int leftResult = 0, rightResult = 0;
    // Recursively process children using only the first non-suppressed packed node
    for (int pnElement = artSPPFNodePackedNodeList(element); pnElement != 0; pnElement = artSPPFPackedNodePackedNodeList(pnElement))
      if (!artSPPFPackedNodeSuppressed(pnElement)) {
        // artText.printf(" Using packed node %d labelled %d %s%n", pnElement, artSPPFPackedNodeLabel(pnElement),
        // artLabelInternalStrings[artSPPFPackedNodeLabel(pnElement)]);

        int leftChild = artSPPFPackedNodeLeftChild(pnElement);
        int rightChild = artSPPFPackedNodeRightChild(pnElement);
        int leftFold = artFolds[artSPPFPackedNodeLabel(pnElement) - 2];
        int rightFold = artFolds[artSPPFPackedNodeLabel(pnElement)];
        if (leftChild != 0) {
          // artText.println("Calling left child " + leftChild + " with fold element " + (artSPPFPackedNodeLabel(pnElement) - 2) + " which is "
          // + artFolds[artSPPFPackedNodeLabel(pnElement) - 2]);
          leftResult = artDerivationAsTermRec(leftChild, children, iTerms, leftFold);// Left fold previous
          // artText.printf("ArtDerivationAsTermRec() at node %d %s: left child result is %d%n", element, artLabelInternalStrings[artSPPFNodeLabel(element)],
          // leftResult);
        }

        // artText.println("Calling right child " + rightChild + " with fold element " + artSPPFPackedNodeLabel(pnElement) + " which is "
        // + artFolds[artSPPFPackedNodeLabel(pnElement)]);

        rightResult = artDerivationAsTermRec(rightChild, children, iTerms, rightFold);
        // artText.printf("ArtDerivationAsTermRec() at node %d %s: right child result is %d%n", element, artLabelInternalStrings[artSPPFNodeLabel(element)],
        // rightResult);

        break;
      }

    artSPPFNodeResetVisited(element); // Unset the visited flag on the way out to allow un-sharing

    // 3. Compute unified result of children - we want the rightmost non-zero result
    int childResult = rightResult != 0 ? rightResult : leftResult != 0 ? leftResult : 0;
    // artText.printf("ArtDerivationAsTermRec() at node %d %s: unified child result is %d%n", element, artLabelInternalStrings[artSPPFNodeLabel(element)],
    // childResult);

    // 4. If we are an intermediate node, then just propogate the childResult up
    if (artKindOfs[artSPPFNodeLabel(element)] == ARTK_INTERMEDIATE) {
      // artText.printf("ArtDerivationAsTermRec() at node %d %s: intermediate node returns %d%n", element, artLabelInternalStrings[artSPPFNodeLabel(element)],
      // childResult);
      return childResult;
    }

    // 5. If we get here then we are a symbol node: do hats first
    if (children == parentChildren) { // we are folding
      if (fold == ARTFOLD_UNDER) {
        // artText.printf("ArtDerivationAsTermRec() at symbol node %d %s: fold under node returns zero%n", element,
        // artLabelInternalStrings[artSPPFNodeLabel(element)]);
        return 0;
      }
      if (fold == ARTFOLD_OVER) {
        int ret = childResult != 0 ? childResult : element;
        // artText.printf("ArtDerivationAsTermRec() at symbol node %d %s: fold over returns %d%n", element, artLabelInternalStrings[artSPPFNodeLabel(element)],
        // ret);
        return ret;
      }
    }

    // 6. If we get here then we are a nonfolding symbol node, so make a new term and insert it in the parent list
    int[] childrenArray = new int[children.size()]; // Build int[] from List<Integer>
    for (int i = 0; i < childrenArray.length; i++)
      childrenArray[i] = children.get(i);
    int newTermNode = childResult != 0 ? childResult : element;
    String symbolString = artLabelInternalStrings[artSPPFNodeLabel(newTermNode)];
    // Strip whitespace from builtins: use Java whitespace definition which is wrong in general
    if (artKindOfs[artSPPFNodeLabel(newTermNode)] == ARTK_BUILTIN_TERMINAL)
      symbolString = artLexeme(artSPPFNodeLeftExtent(newTermNode), artSPPFNodeRightExtent(newTermNode));

    // artLexer.artInputString.substring(artSPPFNodeLeftExtent(newTermNode), artSPPFNodeRightExtent(newTermNode)).strip();

    parentChildren.add(iTerms.findTerm(symbolString, childrenArray));
    // artText.printf("ArtDerivationAsTermRec() at symbol node %d %s: making new derivation tree node and returning zero%n", element,
    // artLabelInternalStrings[artSPPFNodeLabel(element)]);

    // artText.println("** at node " + element + " found term " + (parentChildren.get(parentChildren.size() - 1)) + ": "
    // + iTerms.toString(parentChildren.get(parentChildren.size() - 1)) + " and returning zero");
    return 0;
  }

  public int artDerivationAsTerm(ITerms iTerms) {
    artSPPFResetVisitedFlags();
    List<Integer> list = new LinkedList<>();
    artDerivationAsTermRec(artSPPFRoot(), list, iTerms, ARTFOLD_NONE);
    return list.get(0); // A little suprising... artDerivationAsTermRec gathers terms into the list; for the root that will be [s()]
  }

  private void artDerivationSelectFirstRec(int element) {
    // artText.printf("SelectFirstDerivationRec() at node %d%n", element);

    if (artSPPFNodeVisited(element)) {
      // artText.println("Already visited - aborting");
      return;
    }

    artSPPFNodeSetVisited(element);
    artSPPFNodeSetSelected(element);

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp))
      if (!artSPPFPackedNodeSuppressed(tmp)) {
        artSPPFPackedNodeSetSelected(tmp);
        // artText.printf("Selecting element %d%n", tmp);
        int leftChild = artSPPFPackedNodeLeftChild(tmp);
        if (leftChild != 0) artDerivationSelectFirstRec(leftChild);
        artDerivationSelectFirstRec(artSPPFPackedNodeRightChild(tmp));
        break;
      }
  }

  @Override
  public void artDerivationSelectFirst() {
    artSPPFResetVisitedFlags();
    artDerivationSelectFirstRec(artSPPFRoot());
    artSPPFResetVisitedFlags();
    artDerivationSelectCompleteTime = artReadClock();
  }

  private boolean artIsAmbiguousRec(int element) {
    // System.out.printf("isAmbiguousRec() at node %d%n", element);
    boolean ret = false;

    if (artSPPFNodeVisited(element)) {
      // System.out.println("Already visited - aborting");
      return ret;
    }

    artSPPFNodeSetVisited(element);

    int unsuppressedPackedNodeCount = 0;
    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp))
      if (!artSPPFPackedNodeSuppressed(tmp)) {
        if (++unsuppressedPackedNodeCount > 1) {
          System.out.print("SPPF node " + element + " has more than one unsuppressed child");
          ret = true;
        }
        int leftChild = artSPPFPackedNodeLeftChild(tmp);
        if (leftChild != 0) ret |= artIsAmbiguousRec(leftChild);
        ret |= artIsAmbiguousRec(artSPPFPackedNodeRightChild(tmp));
      }
    return ret;
  }

  @Override
  public boolean artIsAmbiguous() {
    artSPPFResetVisitedFlags();
    boolean ret = artIsAmbiguousRec(artSPPFRoot());
    artSPPFResetVisitedFlags();
    return ret;
  }

  private void artDerivationSelectAllRec(int element) {
    // text.printf(TextLevel.TRACE, "selectFirstDerivationRec() at node %d%n", element);

    if (artSPPFNodeVisited(element)) {
      // text.println(TextLevel.TRACE, "Already visited - aborting");
      return;
    }

    artSPPFNodeSetVisited(element);
    artSPPFNodeSetSelected(element);

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp))
      if (!artSPPFPackedNodeSuppressed(tmp)) {
        artSPPFPackedNodeSetSelected(tmp);
        int leftChild = artSPPFPackedNodeLeftChild(tmp);
        if (leftChild != 0) artDerivationSelectAllRec(leftChild);
        artDerivationSelectAllRec(artSPPFPackedNodeRightChild(tmp));
      }
  }

  @Override
  public void artDerivationSelectAll() {
    artSPPFResetVisitedFlags();
    artDerivationSelectAllRec(artSPPFRoot());
    artSPPFResetVisitedFlags();
  }

  private void artDerivationSelectNextRec(int element) {
    /* Not yet implemented */
  }

  @Override
  public boolean artDerivationSelectNext() {
    artSPPFResetVisitedFlags();
    artDerivationSelectNextRec(artSPPFRoot());
    artSPPFResetVisitedFlags();
    return false;
  }

  /**********************************************/

  private int artRenderKind = artRenderKindIllegal;

  private final String artSymbolNodeStyle = "";
  private final String artPackedNodeStyle = "style=rounded";
  private final String artIntermediateNodeStyle = "style=filled fillcolor=grey90";
  private final String artDerivationNodeStyle = "";

  private final String artAmbiguousStyle = "color=red";
  private final String artAllSuppressedStyle = "style=filled fillcolor=red";

  private final String artSuppressedStyle = "color=orange";
  private final String artSuppressedInTWEStyle = "color=magenta";
  private final String artInTWEStyle = "color=green3";
  private final String artSelectedStyle = "color=blue";

  private void artRenderSPPFNode(ARTText text, String title, String label, String style) {
    if (style != null) // In the new style, we only need to render nodes with non-default styles
      text.println("\"" + title + "\"[" + style + (label != null ? (" label = \"" + label + "\"") : "") + "]");
  }

  private void artRenderSPPFEdge(ARTText text, String elementLabel, String parentLabel, String style) {
    text.println("\"" + parentLabel + "\"->\"" + elementLabel + "\"" + " [" + style + "]");
  }

  private boolean artElementIsVisible(int element, boolean elementIsPacked) {
    switch (artRenderKind) {
    case artRenderKindDerivation:
      if (elementIsPacked) return false;

      if (!artSPPFNodeSelected(element)) return false;

      if (artKindOfs[artSPPFNodeLabel(element)] == ARTK_INTERMEDIATE) return false;

      return true;

    case artRenderKindSPPF:
      if (!elementIsPacked) return true;

      return artSPPFNodeArity(artSPPFPackedNodeParent(element)) > 1;

    default:
      return true;
    }
  }

  private boolean artElementIsRecursable(int element, boolean elementIsPacked) {
    switch (artRenderKind) {
    case artRenderKindDerivation:
      if (elementIsPacked)
        return artSPPFPackedNodeSelected(element);
      else
        return artSPPFNodeSelected(element);

    default:
      return true;
    }
  }

  private String artRenderSPPFNodeTitle(int element) {
    return element + ":" + getArtLabelInternalStrings()[artSPPFNodeLabel(element)] + "  " + artSPPFNodeLeftExtent(element) + ","
        + artSPPFNodeRightExtent(element);
  }

  private String artRenderSPPFPackedNodeTitle(int element) {
    if (element == 0) return "null";
    return element + ":" + getArtLabelInternalStrings()[artSPPFPackedNodeLabel(element)] + "  " + artSPPFPackedNodePivot(element);
  }

  private String artRenderGSSNodeTitle(int element) {
    return artGSSNodeLevel(element) + " " + getArtLabelInternalStrings()[artGSSNodeLabel(element)];
  }

  private void artWriteSPPFRec(ARTText text, int element, int parent, boolean parentIsPacked, int level, ARTLexerV3 tweSet) {
    if (artElementIsVisible(element, false) && parent != 0)
      artRenderSPPFEdge(text, artRenderSPPFNodeTitle(element), parentIsPacked ? artRenderSPPFPackedNodeTitle(parent) : artRenderSPPFNodeTitle(parent), "");

    if (artSPPFNodeVisited(element)) return;

    artSPPFNodeSetVisited(element);
    int newParent = parent;
    boolean newParentIsPacked = parentIsPacked;

    String style = artKindOfs[artSPPFNodeLabel(element)] == ARTK_INTERMEDIATE ? artIntermediateNodeStyle : artSymbolNodeStyle;
    if (artRenderKind == artRenderKindDerivation || artRenderKind == artRenderKindDerivationFull) style = artDerivationNodeStyle;

    if (tweSet != null) if (tweSet.isIn(artSPPFNodeLabel(element), artSPPFNodeLeftExtent(element), artSPPFNodeRightExtent(element)))
      if (tweSet.isSuppressed(artSPPFNodeLabel(element), artSPPFNodeLeftExtent(element), artSPPFNodeRightExtent(element)))
      style += (" " + artSuppressedInTWEStyle);
      else
      style += (" " + artInTWEStyle);

    if (artElementIsVisible(element, false)) {
      boolean allSuppressed = true;
      int packedNodeCount = 0;
      for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
        packedNodeCount++;
        if (!artSPPFPackedNodeSuppressed(tmp)) allSuppressed = false;
      }
      if (packedNodeCount > 1) style += (" " + artAmbiguousStyle);
      if (packedNodeCount > 0 && allSuppressed) style += (" " + artAllSuppressedStyle);
      artRenderSPPFNode(text, artRenderSPPFNodeTitle(element), null, style);
      newParent = element;
      newParentIsPacked = false;
    }

    if (artElementIsRecursable(element, false)) {
      for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
        if (artElementIsVisible(tmp, true)) {
          artRenderSPPFNode(text, artRenderSPPFPackedNodeTitle(tmp), "" + artRenderSPPFPackedNodeTitle(tmp)/* artSPPFPackedNodePivot(tmp) */,
              artSPPFPackedNodeSelected(tmp) ? artPackedNodeStyle + " " + artSelectedStyle
                  : (artSPPFPackedNodeSuppressed(tmp) ? artPackedNodeStyle + " " + artSuppressedStyle : artPackedNodeStyle));

          // we can never have pack nodes visible unless their parent is visible
          artRenderSPPFEdge(text, artRenderSPPFPackedNodeTitle(tmp), artRenderSPPFNodeTitle(element), style);

          newParent = tmp;
          newParentIsPacked = true;
        }
        if (artElementIsRecursable(tmp, true)) {
          if (artSPPFPackedNodeLeftChild(tmp) != 0)
            artWriteSPPFRec(text, artSPPFPackedNodeLeftChild(tmp), newParent, newParentIsPacked, level == -1 ? level : level + 2, tweSet);
          artWriteSPPFRec(text, artSPPFPackedNodeRightChild(tmp), newParent, newParentIsPacked, level == -1 ? level : level + 2, tweSet);
        }
      }
    }
  }

  @Override
  public void artWriteSPPF(ARTText text, int renderKind, ARTLexerV3 tweSet) {
    this.artRenderKind = renderKind;

    if (renderKind == artRenderKindGSS) {
      artRenderSPPFNode(text, artRenderGSSNodeTitle(artRootGSSNode), null, "");
      for (int tmp = artGSSNodeFirst(); tmp != 0; tmp = artGSSNodeNext())
        artRenderSPPFNode(text, null, artRenderGSSNodeTitle(tmp), "");
      for (int tmp = artGSSEdgeFirst(); tmp != 0; tmp = artGSSEdgeNext())
        artRenderSPPFEdge(text, artRenderGSSNodeTitle(artGSSEdgeDestination(tmp)), artRenderGSSNodeTitle(artGSSEdgeSource(tmp)), "");
    } else if (renderKind == artRenderKindDerivation || renderKind == artRenderKindDerivationFull) {
      artWriteSPPFRec(text, artSPPFRoot(), 0, false, 0, tweSet);
    } else {
      artSPPFResetVisitedFlags();
      artWriteSPPFRec(text, artSPPFRoot(), 0, false, 0, tweSet);
      if (renderKind == artRenderKindSPPFFull)
        for (int element = artSPPFNodeFirst(); element != 0; element = artSPPFNodeNext())
          artWriteSPPFRec(text, element, 0, false, -1, tweSet);
      else if (renderKind == artRenderKindSPPF) artWriteSPPFRec(text, artSPPFRoot(), 0, false, 0, tweSet);
      artSPPFResetVisitedFlags();
    }
  }

  abstract protected void artInitialise();

  abstract protected void artParseBody(int nonterminalLabel);

  @Override
  public void artParse(String inputString, int nonterminalLabel, ARTGLLAttributeBlock startAttributes) {
    artInputString = inputString;
    artIsInLanguage = false;

    if (artKindOfs != null && artKindOfs[nonterminalLabel] != ARTK_NONTERMINAL) {
      System.out.println("Internal error: parse start label " + nonterminalLabel + " is not a nonterminal");
    }

    artInitialise();
    artParseBody(nonterminalLabel);

    if (artInadmissable) System.out.println("Specification inadmissable - EBNF not supported");

    if (artHasChoosers)
      artChoose();
    else
      artDisambiguatePriorityLongestMatch();

    if (artParserKind.indexOf("MGLL") != 0) artDerivationSelectFirst();

    if (artDirectives.b("parseCounts")) artComputeParseCounts();

    // artProcessPostParseTWE(true);

    if (artParserKind.indexOf("MGLL") != 0) artEvaluator(startAttributes);
  }

  protected int artNextFreeNodeNumber = 1;
  protected String artInputString;

  @Override
  public void artEvaluator(ARTGLLAttributeBlock artAttributes) {
    artRDT = new ARTGLLRDT("RDT", artKindOfs, artLabelStrings, artInputString);
    ARTGLLRDTVertex artNewParent = new ARTGLLRDTVertex(artNextFreeNodeNumber++,
        new ARTGLLRDTPayload(artRDT, artSPPFNodeLeftExtent(artRootSPPFNode), artSPPFNodeRightExtent(artRootSPPFNode), artSPPFNodeLabel(artRootSPPFNode), null));
    artRDT.setRoot(artNewParent);
    boolean artNewWriteable = true;
    artEvaluate(new ARTGLLRDTHandle(artRootSPPFNode), artAttributes, artNewParent, artNewWriteable);
    artAttributeEvaluateCompleteTime = artReadClock();
  }

  @Override
  public void artWriteRDT(String filename) {
    artRDT.printDot(filename);
  }

  @Override
  public void artPrintRDT() {
    artPrintRDTRec(artRDT, artRDT.getRoot(), 0);
  }

  private void artPrintRDTRec(ARTGLLRDT tree, ARTGLLRDTVertex vertex, int level) {
    if (vertex == null) return;
    // Preorder printout
    for (int i = 0; i < level; i++)
      System.out.print("  ");
    System.out.printf("%d: %s%n", vertex.getKey(), vertex.getPayload().toString(tree));
    artPrintRDTRec(tree, vertex.getChild(), level + 1);
    artPrintRDTRec(tree, vertex.getSibling(), level);
  }

  /* Support for TWE sets below this line */
  protected class ARTRightExtentNode {
    public int rightExtent;
    public ARTRightExtentNode next;

    ARTRightExtentNode(int rightExtent, ARTRightExtentNode next) {
      this.rightExtent = rightExtent;
      this.next = next;
    }

  }

  private boolean artContains(int rightExtent, ARTRightExtentNode list) {
    while (list != null)
      if (list.rightExtent == rightExtent)
        return true;
      else
        list = list.next;
    return false;
  }

  protected ARTRightExtentNode[][] artTriples; // Indexed as leftExtent, token, rightExtent
  // shortcut to access the elements in classical GLL
  public int artInputSuccessorBuffer[]; // Holds runs of successor handles; each run is terminated by -1

  private void artLexBuildTriplesFromTWESet() {
    // First dimension is the index into the input
    // Second dimension is the token
    // Third dimension is the sequence of right extents
    artTriples = new ARTRightExtentNode[artLexer.artInputLength + 1][];
    System.out.println("Initialised artTriples to length " + artTriples.length);
    int indexedTWESet[][][] = artLexer.lexicaliseToIndexedTWESet(artLexer.artInputString);
    for (int i = 0; i < indexedTWESet.length; i++) {
      if (artTriples[i] == null) artTriples[i] = new ARTRightExtentNode[artTokenExtent];
      for (int token = 0; token < indexedTWESet[i].length; token++)
        for (int jIndex = 0; jIndex < indexedTWESet[i][token].length; jIndex++)
          artTriples[i][token] = new ARTRightExtentNode(indexedTWESet[i][token][jIndex], artTriples[i][token]);
    }
  }

  protected int artLexBuildTriplesFromFile(String filename) {
    int[][][] tweSet;
    try {
      tweSet = artLexer.readIndexedTWESet(filename);
    } catch (FileNotFoundException e1) {
      throw new ARTUncheckedException("Unable to open TWE set file '" + filename + "'");
    }

    // Constants representing the length of the dimensions; in Java these are not required since we could interrogate the array objects, but we want
    // compatibility with C and non-OO lanuages
    artTriples = new ARTRightExtentNode[tweSet.length + 1][];
    artLexer.artInputIndex = 0;
    artLexer.artInputLength = tweSet.length - 2;
    for (int i = 0; i < tweSet.length; i++) {
      for (int t = 0; t < tweSet[0].length; t++)

        if (tweSet[i][t] != null) for (int e = 0; e < tweSet[i][t].length; e++) {
          if (artTriples[i] == null) artTriples[i] = new ARTRightExtentNode[tweSet[0].length];
          if (!artContains(artLexer.artInputIndex, artTriples[i][t])) {
            artTriples[i][t] = new ARTRightExtentNode(tweSet[i][t][e], artTriples[i][t]);
            // System.out.println("Added " + t + " with extents " + i + ", " + tweSet[i][t][e]);
          }
        }
    }

    if (artDirectives.b("inputPrint")) {
      System.out.println("TWE set as loaded by MGLL parser");
      artPrintTriples();
    }
    return artLexer.getEosWhitespacePrefix();
  }

  private void artPrintTriples() {
    if (artTriples == null) return;
    // Now print out the triples
    for (int i = 0; i < artTriples.length; i++) {
      if (artTriples[i] != null) {
        System.out.print(i + ": ");
        for (int t = 0; t < artTriples[i].length; t++)
          for (ARTRightExtentNode n = artTriples[i][t]; n != null; n = n.next)
            System.out.print(" " + artLabelInternalStrings[t] + "." + n.rightExtent);
        System.out.println();
      }
    }
  }

  protected void artLexBuildSuccessorSets() {
    // Populate the visible data structures which represnet the \Chi_{a,i} sets using the triples array, which may be discarded after this phase
    // These are the data structures to be constructed:
    // int InputPairBuffer[]; // Holds all unique input pairs; index into this buffer of a pair (a,i) is its handle in descriptors
    // int InputPairIndex[][]; // Index of input pairs: contents of location (a, i) is the address of (a,i) in InputPair Buffer, a.k.a the pair's handle
    // int InputInitialPairBuffer[]; // Holds pair handles for state 0
    // int inputSuccessorPairs[][][]; //Blocks of successor pairs for each (a, i) - these are the \Chi_{a,i} sets from the paper as lists of pair handles

    // Enumerate unique pairs
    int pairCardinality = 0;
    for (int leftExtent = 0; leftExtent < artTriples.length; leftExtent++)
      if (artTriples[leftExtent] != null) for (int tokenNumber = 0; tokenNumber < artTriples[leftExtent].length; tokenNumber++)
        if (artTriples[leftExtent][tokenNumber] != null) pairCardinality++;

    // Construct sparse map from pairs to integers and store pairs in pairs buffer; create InputSuccessorIndex as we go
    artInputPairBuffer = new int[pairCardinality * 2];
    artInputPairIndex = new int[artTriples.length + 1][];
    artInputFirstPairAtLeftExtent = new int[artTriples.length + 1];
    artInputSuccessorIndex = new int[artTriples.length + 1][];
    pairCardinality = 0;
    for (int leftExtent = 0; leftExtent < artTriples.length; leftExtent++) {
      if (artTriples[leftExtent] == null) continue;
      artInputPairIndex[leftExtent] = new int[artTokenExtent];
      artInputSuccessorIndex[leftExtent] = new int[artTokenExtent];
      artInputFirstPairAtLeftExtent[leftExtent] = pairCardinality; // This index is used by classical GLL to fetch tokens from the input pair buffer
      for (int tokenNumber = 0; tokenNumber < artTokenExtent; tokenNumber++) {
        if (artTriples[leftExtent][tokenNumber] == null) continue; // There are no instances of this token leaving this position
        artInputPairIndex[leftExtent][tokenNumber] = pairCardinality;
        artInputPairBuffer[pairCardinality++] = tokenNumber;
        artInputPairBuffer[pairCardinality++] = leftExtent;
        if (ARTTRACETWE) System.out.printf("Loaded pair (%s,%d) to inputPairBuffer[%d]\n", artLabelStrings[tokenNumber], leftExtent,
            artInputPairIndex[leftExtent][tokenNumber]);
      }
    }

    // Enumerate successorBuffer
    int successorBufferCardinality = 0;
    if (artTriples[0] != null) for (int tokenNumber = 0; tokenNumber < artTokenExtent; tokenNumber++)
      if (artTriples[0][tokenNumber] != null) {
        if (ARTTRACETWE) System.out.printf("Initial pair search found token %s\n", artLabelStrings[tokenNumber]);
        successorBufferCardinality++;
      }

    successorBufferCardinality++; // leave a space for the terminating -1

    if (ARTTRACETWE) System.out.printf("Initial pair cardinality: %d\n", successorBufferCardinality);

    // Now add in the cardinalities of the successor blocks
    for (int leftExtent = 0; leftExtent < artTriples.length; leftExtent++) {
      if (artTriples[leftExtent] == null) continue; // There are no tokens leaving this leftExtent position

      for (int tokenNumber = 0; tokenNumber < artTokenExtent; tokenNumber++) {
        if (artTriples[leftExtent][tokenNumber] == null) continue; // There are no instances of this token leaving this leftExtent position

        if (ARTTRACETWE) System.out.printf("Counting successors for pair(%s, %d)\n", artLabelStrings[tokenNumber], leftExtent);
        successorBufferCardinality++; // leave a space for the terminating -1

        for (ARTRightExtentNode tmp = artTriples[leftExtent][tokenNumber]; tmp != null; tmp = tmp.next) {
          int rightExtent = tmp.rightExtent;

          if (ARTTRACETWE) System.out.printf("Pair(%s, %d) has rightExtent %d\n", artLabelStrings[tokenNumber], leftExtent, rightExtent);

          // Now scan destination state for all of its tokens
          if (artTriples[rightExtent] != null) // There may be no out edges at all; certain for the last state
            for (int successorTokenNumber = 0; successorTokenNumber < artTokenExtent; successorTokenNumber++) {
              if (artTriples[rightExtent][successorTokenNumber] == null) continue;
              successorBufferCardinality++;
              if (ARTTRACETWE) System.out.printf("Pair(%s, %d) has successor (%s, %d)\n", artLabelStrings[tokenNumber], leftExtent,
                  artLabelStrings[successorTokenNumber], rightExtent);
            }
        }
      }
    }

    if (ARTTRACETWE) System.out.printf("Successor buffer cardinality: %d\n", successorBufferCardinality);

    // Allocate successor buffer
    artInputSuccessorBuffer = new int[successorBufferCardinality];

    // Load successorBuffer with initial pairs
    successorBufferCardinality = 0;
    if (artTriples[0] != null) for (int tokenNumber = 0; tokenNumber < artTokenExtent; tokenNumber++)
      if (artTriples[0][tokenNumber] != null) artInputSuccessorBuffer[successorBufferCardinality++] = artInputPairIndex[0][tokenNumber];

    artInputSuccessorBuffer[successorBufferCardinality++] = -1; // Terminate initial block

    // Load successorBuffer with successor blocks, indexing as we go
    for (int leftExtent = 0; leftExtent < artTriples.length; leftExtent++) {
      if (artTriples[leftExtent] == null) continue; // There are no tokens leaving this leftExtent position

      for (int tokenNumber = 0; tokenNumber < artTokenExtent; tokenNumber++) {
        if (artTriples[leftExtent][tokenNumber] == null) continue; // There are no instances of this token leaving this leftExtent position

        artInputSuccessorIndex[leftExtent][tokenNumber] = successorBufferCardinality;

        if (ARTTRACETWE) System.out.printf("Loading successors for pair(%s, %d) to successorBufferlocation \n", artLabelStrings[tokenNumber], leftExtent);

        for (ARTRightExtentNode tmp = artTriples[leftExtent][tokenNumber]; tmp != null; tmp = tmp.next) {
          int rightExtent = tmp.rightExtent;

          // Now scan destination state for all of its tokens
          if (artTriples[rightExtent] != null) // There may be no out edges at all; certain for the last state
            for (int successorTokenNumber = 0; successorTokenNumber < artTokenExtent; successorTokenNumber++) {
              if (artTriples[rightExtent][successorTokenNumber] == null) continue;
              artInputSuccessorBuffer[successorBufferCardinality++] = artInputPairIndex[rightExtent][successorTokenNumber];

              if (ARTTRACETWE) System.out.printf("Loaded pair(%s, %d) successor (%s, %d) to InputSuccessorBuffer[%d]\n", artLabelStrings[tokenNumber],
                  leftExtent, artLabelStrings[successorTokenNumber], rightExtent, successorBufferCardinality - 1);
            }
        }
        artInputSuccessorBuffer[successorBufferCardinality++] = -1; // Terminate initial block
      }
    }

    // Dump successorBuffer
    if (ARTTRACETWE) {
      for (int i = 0; artInputSuccessorBuffer[i] != -1; i++)
        System.out.printf("Initial pair [%d](%s, %d)\n", i, artLabelStrings[artInputPairBuffer[artInputSuccessorBuffer[i]]],
            artInputPairBuffer[artInputSuccessorBuffer[i] + 1]);

      for (int leftExtent = 0; leftExtent < artTriples.length + 1; leftExtent++) {
        if (artInputSuccessorIndex[leftExtent] == null) continue; // There are no tokens leaving this leftExtent position

        for (int tokenNumber = 0; tokenNumber < artTokenExtent; tokenNumber++) {
          if (artInputSuccessorIndex[leftExtent][tokenNumber] == 0) continue; // There are no instances of this token leaving this leftExtent position
          for (int i = artInputSuccessorIndex[leftExtent][tokenNumber]; artInputSuccessorBuffer[i] != -1; i++)
            System.out.printf("Pair (%s, %d) has successor %d:(%s, %d)\n", artLabelStrings[tokenNumber], leftExtent, i,
                artLabelStrings[artInputPairBuffer[artInputSuccessorBuffer[i]]], artInputPairBuffer[artInputSuccessorBuffer[i] + 1]);
        }
      }
    }
  }

  public void artLexDump(String string) {// dump pair buffer
    System.out.println(string);
    if (artInputPairBuffer == null) return;
    for (int i = 0; i < artInputPairBuffer.length - 2; i += 2)
      System.out.printf("%d: %d %s %s\n", i, artInputPairBuffer[i + 1], artLabelStrings[artInputPairBuffer[i]],
          artLexer.artInputString.substring(artInputPairBuffer[i + 1], artInputPairBuffer[i + 3]).trim());
  }

  // This is the lexer interface used by classicial GLL
  public void artLexicaliseForV3GLL(String stringInput, String filename) {
    // System.out.println("**** Start of front end lexer");
    artLexer.artInputString = stringInput + "\0";
    artLexer.artLoadInputArray(stringInput);
    artLexer.artInputLength = artLexer.artInputString.length();
    artTokenExtent = ARTGLLParserBase.ARTL_EPSILON;

    artTriples = new ARTRightExtentNode[artLexer.artInputLength + 1][];

    if (filename != null) {
      artWhitespaceEOSPrefixLength = artLexBuildTriplesFromFile(filename);
    } else {
      boolean suppressWhitespace = true;
      int leftExtent;

      artLexer.artInputIndex = 0;
      do {
        leftExtent = artLexer.artInputIndex;
        if (suppressWhitespace) artLexer.artLexicalisePreparseWhitespace();
        artLexer.artMatchLongestRaw();
        suppressWhitespace = artKindOfs[artLexer.artLongestToken] != ARTGLLParserBase.ARTK_CHARACTER_TERMINAL;

        if (artTriples[leftExtent] == null) artTriples[leftExtent] = new ARTRightExtentNode[artTokenExtent];

        // System.out.println("** Adding " + artLexer.artLongestToken + " " + artLabelInternalStrings[artLexer.artLongestToken] + " with extents " + leftExtent
        // + ", " + artLexer.artInputIndex);

        if (!artContains(artLexer.artInputIndex, artTriples[leftExtent][artLexer.artLongestToken]))
          artTriples[leftExtent][artLexer.artLongestToken] = new ARTRightExtentNode(artLexer.artInputIndex, artTriples[leftExtent][artLexer.artLongestToken]); // Head
      } while (artLexer.artLongestToken != ARTGLLParserBase.ARTL_EOS);
      artWhitespaceEOSPrefixLength = artLexer.artInputLength - leftExtent;
    }
    // System.out.println("Triples from longest match front end");
    // artPrintTriples();
    artLexBuildSuccessorSets();
    // System.out.println("Lexer dump after building the successor sets");
    // artLexDump("lexical dump longest match");
    // System.out.println("**** End of front end lexer");
  }
}
